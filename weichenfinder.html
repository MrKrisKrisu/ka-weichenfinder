<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karlsruhe Tramkarte</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.5.2/ol.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v7.5.2/dist/ol.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #map {
            width: 100%;
            height: 100vh;
        }

        .search-container {
            position: absolute;
            top: 20px;
            left: 60px;
            z-index: 1000;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            min-width: 280px;
        }

        .search-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .search-input:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .autocomplete-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            margin-top: -4px;
        }

        .autocomplete-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .autocomplete-item:hover {
            background: #f5f5f5;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .ol-popup {
            position: absolute;
            background-color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            bottom: 12px;
            left: -50px;
            min-width: 280px;
            max-width: 400px;
        }

        .ol-popup:after, .ol-popup:before {
            top: 100%;
            border: solid transparent;
            content: " ";
            height: 0;
            width: 0;
            position: absolute;
            pointer-events: none;
        }

        .ol-popup:after {
            border-top-color: white;
            border-width: 10px;
            left: 48px;
            margin-left: -10px;
        }

        .ol-popup:before {
            border-top-color: rgba(0, 0, 0, 0.1);
            border-width: 11px;
            left: 48px;
            margin-left: -11px;
        }

        .ol-popup-closer {
            position: absolute;
            top: 8px;
            right: 8px;
            cursor: pointer;
            font-size: 20px;
            color: #999;
        }

        .ol-popup-closer:hover {
            color: #333;
        }

        .popup-content h3 {
            margin: 0 0 12px 0;
            color: #333;
            font-size: 18px;
        }

        .popup-content table {
            width: 100%;
            border-collapse: collapse;
        }

        .popup-content td {
            padding: 6px 8px;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }

        .popup-content td:first-child {
            font-weight: 600;
            color: #666;
            width: 45%;
        }

        .popup-content tr:last-child td {
            border-bottom: none;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px 40px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            font-size: 16px;
        }
    </style>
</head>
<body>
<div id="map"></div>
<div class="search-container">
    <input type="text" class="search-input" placeholder="Weichennummer suchen (z.B. 73, W73, W 73 E)..."
           id="searchInput">
    <div class="autocomplete-list" id="autocompleteList"></div>
</div>
<div id="popup" class="ol-popup">
    <a href="#" id="popup-closer" class="ol-popup-closer">×</a>
    <div id="popup-content" class="popup-content"></div>
</div>
<div class="loading" id="loading">Lade Daten...</div>

<script>
    const KARLSRUHE_CENTER = [8.4037, 49.0094];
    const INITIAL_ZOOM = 12;

    let switchesData = [];
    let stopsData = [];
    let signalsData = [];
    let map, vectorSource, stopsSource, tracksSource, signalsSource, popupOverlay;

    const iconCache = {
        st1: null,
        st2: null
    };

    function initIconCache() {
        const st1SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                <rect x="2" y="2" width="20" height="20" fill="#2196F3" stroke="#333" stroke-width="1"/>
                <text x="12" y="16" font-family="Arial" font-size="14" font-weight="bold" fill="white" text-anchor="middle">S</text>
            </svg>`;

        const st2SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                <rect x="2" y="2" width="20" height="20" fill="#2196F3" stroke="#333" stroke-width="1"/>
                <text x="12" y="16" font-family="Arial" font-size="14" font-weight="bold" fill="white" text-anchor="middle">W</text>
            </svg>`;

        iconCache.st1 = 'data:image/svg+xml;base64,' + btoa(st1SVG);
        iconCache.st2 = 'data:image/svg+xml;base64,' + btoa(st2SVG);
    }

    const translations = {
        'ref': 'Nummer',
        'name': 'Name',
        'railway:switch': 'Weichentyp',
        'railway:turnout_side': 'Abzweigrichtung',
        'railway:switch:heated': 'Beheizung',
        'railway:maxspeed:straight': 'Geschw. geradeaus',
        'railway:maxspeed:diverging': 'Geschw. abzweigend',
        'railway:switch:electric': 'Elektrisch',
        'railway:local_operated': 'Vor Ort bedient',
        'railway:switch:movable_frog': 'Bewegliche Herzstückspitze',
        'railway:switch:frog_number': 'Herzstückzahl',
        'railway:switch:frog': 'Herzstücktyp',
        'railway:switch:resetting': 'Rückfallweiche',
        'operator': 'Betreiber',
        'railway:signal:switch': 'Signaltyp',
        'railway:signal:switch:form': 'Signalform',
        'railway:signal:switch:states': 'Signalzustände'
    };

    const valueTranslations = {
        'default': 'Normal',
        'three_way': 'Dreiwegweiche',
        'single_slip': 'Einfache Kreuzungsweiche',
        'double_slip': 'Doppelte Kreuzungsweiche',
        'wye': 'Y-Weiche',
        'abt': 'Abt-Weiche',
        'left': 'Links',
        'right': 'Rechts',
        'yes': 'Ja',
        'no': 'Nein',
        'lift': 'Hebend',
        'light': 'Licht',
        'sign': 'Schild'
    };

    const cachedStyles = {};

    function createIconStyle(iconCode, color, fontSize = 12) {
        const key = `${iconCode}-${color}-${fontSize}`;
        if (!cachedStyles[key]) {
            cachedStyles[key] = new ol.style.Style({
                text: new ol.style.Text({
                    text: iconCode,
                    font: `900 ${fontSize}px "Font Awesome 6 Free"`,
                    fill: new ol.style.Fill({color: color}),
                    stroke: new ol.style.Stroke({color: '#fff', width: 2})
                })
            });
        }
        return cachedStyles[key];
    }

    function createSVGStyle(iconKey) {
        const key = `svg-${iconKey}`;
        if (!cachedStyles[key]) {
            cachedStyles[key] = new ol.style.Style({
                image: new ol.style.Icon({
                    src: iconCache[iconKey],
                    scale: 0.6
                })
            });
        }
        return cachedStyles[key];
    }

    function initMap() {
        const baseLayer = new ol.layer.Tile({
            source: new ol.source.XYZ({
                url: 'https://b.basemaps.cartocdn.com/light_all/{z}/{x}/{y}@2x.png',
                attributions: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, © <a href="https://carto.com/attributions">CARTO</a>'
            })
        });

        tracksSource = new ol.source.Vector();
        const tracksLayer = new ol.layer.Vector({
            source: tracksSource,
            style: new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: 'rgba(80, 80, 80, 0.6)',
                    width: 3
                })
            }),
            updateWhileAnimating: false,
            updateWhileInteracting: false,
            renderBuffer: 100,
            zIndex: 1
        });

        stopsSource = new ol.source.Vector();
        const stopsLayer = new ol.layer.Vector({
            source: stopsSource,
            style: createIconStyle('\uf207', '#1976D2', 14),
            updateWhileAnimating: false,
            updateWhileInteracting: false,
            zIndex: 3
        });

        signalsSource = new ol.source.Vector();
        const signalsLayer = new ol.layer.Vector({
            source: signalsSource,
            style: function (feature) {
                const signalType = feature.get('signalData').tags['railway:signal:switch'];
                if (signalType === 'DE-BOStrab:st1') return createSVGStyle('st1');
                if (signalType === 'DE-BOStrab:st2') return createSVGStyle('st2');
                return null;
            },
            updateWhileAnimating: false,
            updateWhileInteracting: false,
            zIndex: 4
        });

        vectorSource = new ol.source.Vector();
        const vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: function (feature) {
                const sw = feature.get('switchData');
                const ref = sw.tags.ref || '';
                return [
                    new ol.style.Style({
                        text: new ol.style.Text({
                            text: '\uf424',
                            font: '900 14px "Font Awesome 6 Free"',
                            fill: new ol.style.Fill({color: '#FF5722'}),
                            stroke: new ol.style.Stroke({color: '#fff', width: 2}),
                            offsetY: 0
                        })
                    }),
                    new ol.style.Style({
                        text: new ol.style.Text({
                            text: ref,
                            font: '10px Arial',
                            fill: new ol.style.Fill({color: '#333'}),
                            stroke: new ol.style.Stroke({color: '#fff', width: 2}),
                            offsetY: 12
                        })
                    })
                ];
            },
            updateWhileAnimating: false,
            updateWhileInteracting: false,
            zIndex: 2
        });

        const popupElement = document.getElementById('popup');
        popupOverlay = new ol.Overlay({
            element: popupElement,
            autoPan: {
                animation: {duration: 250}
            }
        });

        map = new ol.Map({
            target: 'map',
            layers: [baseLayer, tracksLayer, vectorLayer, stopsLayer, signalsLayer],
            overlays: [popupOverlay],
            view: new ol.View({
                center: ol.proj.fromLonLat(KARLSRUHE_CENTER),
                zoom: INITIAL_ZOOM
            })
        });

        map.on('click', function (evt) {
            const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
            if (feature) {
                showPopup(feature, evt.coordinate);
            } else {
                closePopup();
            }
        });

        map.on('pointermove', function (e) {
            const pixel = map.getEventPixel(e.originalEvent);
            const hit = map.hasFeatureAtPixel(pixel);
            map.getTargetElement().style.cursor = hit ? 'pointer' : '';
        });

        document.getElementById('popup-closer').onclick = function () {
            closePopup();
            return false;
        };
    }

    async function loadData() {
        const bbox = '48.94,8.26,49.12,8.52';
        const cacheKey = 'vbk_map_data';
        const cacheTimeKey = 'vbk_map_data_time';
        const cacheMaxAge = 10 * 60 * 1000;

        try {
            const cachedData = localStorage.getItem(cacheKey);
            const cachedTime = localStorage.getItem(cacheTimeKey);
            const now = Date.now();

            if (cachedData && cachedTime) {
                const age = now - parseInt(cachedTime);

                if (age < cacheMaxAge) {
                    const data = JSON.parse(cachedData);
                    processData(data.elements);
                    document.getElementById('loading').style.display = 'none';
                    return;
                } else {
                    const data = JSON.parse(cachedData);
                    processData(data.elements);
                    document.getElementById('loading').style.display = 'none';

                    fetchFreshData(bbox, cacheKey, cacheTimeKey);
                    return;
                }
            }
        } catch (e) {
            console.error('Cache-Fehler:', e);
        }

        await fetchFreshData(bbox, cacheKey, cacheTimeKey);
    }

    async function fetchFreshData(bbox, cacheKey, cacheTimeKey) {
        const query = `
                [out:json][timeout:25][bbox:${bbox}];
                (
                    node["railway"="switch"]["operator"~"Verkehrsbetriebe Karlsruhe|VBK",i];
                    node["public_transport"="stop_position"]["tram"="yes"]["operator"~"Verkehrsbetriebe Karlsruhe|VBK|Albtal-Verkehrs-Gesellschaft|AVG",i];
                    node["railway"="tram_stop"]["operator"~"Verkehrsbetriebe Karlsruhe|VBK|Albtal-Verkehrs-Gesellschaft|AVG",i];
                    node["public_transport"="platform"]["tram"="yes"]["operator"~"Verkehrsbetriebe Karlsruhe|VBK|Albtal-Verkehrs-Gesellschaft|AVG",i];
                    node["railway:signal:switch"~"DE-BOStrab:st1|DE-BOStrab:st2"];
                    way["railway"~"tram|light_rail"]["operator"~"Verkehrsbetriebe Karlsruhe|VBK|Albtal-Verkehrs-Gesellschaft|AVG",i];
                );
                out body;
                >;
                out skel qt;
            `;

        try {
            const response = await fetch('https://overpass-api.de/api/interpreter', {
                method: 'POST',
                body: query
            });
            const data = await response.json();

            try {
                localStorage.setItem(cacheKey, JSON.stringify(data));
                localStorage.setItem(cacheTimeKey, Date.now().toString());
            } catch (e) {
                console.error('LocalStorage voll:', e);
            }

            switchesData = [];
            stopsData = [];
            signalsData = [];
            vectorSource.clear();
            stopsSource.clear();
            signalsSource.clear();
            tracksSource.clear();

            processData(data.elements);
            document.getElementById('loading').style.display = 'none';
        } catch (error) {
            console.error('Fehler beim Laden der Daten:', error);
            document.getElementById('loading').textContent = 'Fehler beim Laden der Daten';
        }
    }

    function deduplicateStops(stops) {
        const grouped = {};

        stops.forEach(stop => {
            const name = stop.tags.name;
            if (!name) return;

            if (!grouped[name]) {
                grouped[name] = [];
            }
            grouped[name].push(stop);
        });

        const deduplicated = [];
        Object.values(grouped).forEach(group => {
            if (group.length === 1) {
                deduplicated.push(group[0]);
            } else {
                const avgLat = group.reduce((sum, s) => sum + s.lat, 0) / group.length;
                const avgLon = group.reduce((sum, s) => sum + s.lon, 0) / group.length;

                deduplicated.push({
                    id: group[0].id,
                    lat: avgLat,
                    lon: avgLon,
                    tags: group[0].tags,
                    type: 'stop',
                    count: group.length
                });
            }
        });

        return deduplicated;
    }

    function simplifyCoords(coords, tolerance = 0.00005) {
        if (coords.length <= 2) return coords;

        const step = Math.max(1, Math.floor(coords.length / 50));
        const simplified = [];
        for (let i = 0; i < coords.length; i += step) {
            simplified.push(coords[i]);
        }
        if (simplified[simplified.length - 1] !== coords[coords.length - 1]) {
            simplified.push(coords[coords.length - 1]);
        }
        return simplified;
    }

    function processData(elements) {
        const nodes = {};
        const tempStops = [];

        elements.forEach(el => {
            if (el.type === 'node') {
                nodes[el.id] = el;
            }
        });

        elements.forEach(el => {
            if (el.type === 'node' && el.tags) {
                if (el.tags.railway === 'switch') {
                    switchesData.push({
                        id: el.id,
                        lat: el.lat,
                        lon: el.lon,
                        tags: el.tags,
                        type: 'switch'
                    });
                } else if (el.tags.public_transport === 'stop_position' ||
                    el.tags.railway === 'tram_stop' ||
                    el.tags.public_transport === 'platform') {
                    tempStops.push({
                        id: el.id,
                        lat: el.lat,
                        lon: el.lon,
                        tags: el.tags,
                        type: 'stop'
                    });
                } else if (el.tags['railway:signal:switch']) {
                    signalsData.push({
                        id: el.id,
                        lat: el.lat,
                        lon: el.lon,
                        tags: el.tags,
                        type: 'signal'
                    });
                }
            } else if (el.type === 'way' && el.tags &&
                (el.tags.railway === 'tram' || el.tags.railway === 'light_rail')) {
                const coords = el.nodes
                    .map(nodeId => nodes[nodeId])
                    .filter(n => n && n.lat && n.lon)
                    .map(n => [n.lon, n.lat]);

                if (coords.length > 1) {
                    const simplified = simplifyCoords(coords);
                    const projectedCoords = simplified.map(c => ol.proj.fromLonLat(c));

                    const feature = new ol.Feature({
                        geometry: new ol.geom.LineString(projectedCoords),
                        trackData: {tags: el.tags, type: 'track'}
                    });
                    tracksSource.addFeature(feature);
                }
            }
        });

        stopsData = deduplicateStops(tempStops);

        displaySwitches();
        displayStops();
        displaySignals();
    }

    function displaySwitches() {
        const features = switchesData.map(sw => {
            const feature = new ol.Feature({
                geometry: new ol.geom.Point(ol.proj.fromLonLat([sw.lon, sw.lat])),
                switchData: sw
            });
            return feature;
        });
        vectorSource.addFeatures(features);
    }

    function displayStops() {
        const features = stopsData.map(stop => {
            const feature = new ol.Feature({
                geometry: new ol.geom.Point(ol.proj.fromLonLat([stop.lon, stop.lat])),
                stopData: stop
            });
            return feature;
        });
        stopsSource.addFeatures(features);
    }

    function displaySignals() {
        const features = signalsData.map(signal => {
            const feature = new ol.Feature({
                geometry: new ol.geom.Point(ol.proj.fromLonLat([signal.lon, signal.lat])),
                signalData: signal
            });
            return feature;
        });
        signalsSource.addFeatures(features);
    }

    function extractSwitchNumber(ref) {
        if (!ref) return null;
        const match = ref.match(/\d+/);
        return match ? match[0] : null;
    }

    function showPopup(feature, coordinate) {
        const data = feature.get('switchData') || feature.get('stopData') ||
            feature.get('signalData') || feature.get('trackData');

        if (!data) return;

        const content = document.getElementById('popup-content');

        let title = 'Objekt';
        let osmType = 'node';
        let osmId = data.id;

        if (data.type === 'switch') {
            title = `Weiche ${data.tags.ref || 'Unbekannt'}`;
        } else if (data.type === 'stop') {
            title = data.tags.name || 'Haltestelle';
        } else if (data.type === 'signal') {
            title = 'Signal';
        } else if (data.type === 'track') {
            title = 'Gleis';
            osmType = 'way';
        }

        let html = `<h3>${title}</h3><table>`;

        Object.entries(data.tags).forEach(([key, value]) => {
            if (key === 'railway' && (value === 'switch' || value === 'tram' || value === 'light_rail')) return;
            if (key === 'public_transport') return;

            const label = translations[key] || key;
            const translatedValue = valueTranslations[value] || value;

            html += `<tr><td>${label}</td><td>${translatedValue}</td></tr>`;
        });

        html += '</table>';
        html += `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #eee;">
                <a href="https://www.openstreetmap.org/${osmType}/${osmId}" target="_blank" style="color: #1976D2; text-decoration: none; font-size: 13px;">
                    Fehler gefunden? Auf OpenStreetMap korrigieren.
                </a>
            </div>`;
        content.innerHTML = html;

        popupOverlay.setPosition(coordinate);
    }

    function closePopup() {
        popupOverlay.setPosition(undefined);
    }

    const searchInput = document.getElementById('searchInput');
    const autocompleteList = document.getElementById('autocompleteList');

    searchInput.addEventListener('input', function () {
        const query = this.value.trim().toLowerCase();

        if (query.length === 0) {
            autocompleteList.style.display = 'none';
            return;
        }

        const matches = switchesData.filter(sw => {
            const ref = sw.tags.ref || '';
            const num = extractSwitchNumber(ref);

            return ref.toLowerCase().includes(query) ||
                (num && num.includes(query)) ||
                ref.replace(/\s/g, '').toLowerCase().includes(query);
        }).slice(0, 10);

        if (matches.length > 0) {
            autocompleteList.innerHTML = matches.map(sw =>
                `<div class="autocomplete-item" data-id="${sw.id}">${sw.tags.ref || 'Unbekannt'}</div>`
            ).join('');
            autocompleteList.style.display = 'block';
        } else {
            autocompleteList.style.display = 'none';
        }
    });

    autocompleteList.addEventListener('click', function (e) {
        if (e.target.classList.contains('autocomplete-item')) {
            const id = parseInt(e.target.dataset.id);
            const sw = switchesData.find(s => s.id === id);

            if (sw) {
                const coord = ol.proj.fromLonLat([sw.lon, sw.lat]);
                map.getView().animate({
                    center: coord,
                    zoom: 18,
                    duration: 500
                });

                setTimeout(() => {
                    const features = vectorSource.getFeatures();
                    const feature = features.find(f => f.get('switchData').id === id);
                    if (feature) {
                        showPopup(feature, coord);
                    }
                }, 600);
            }

            searchInput.value = e.target.textContent;
            autocompleteList.style.display = 'none';
        }
    });

    document.addEventListener('click', function (e) {
        if (!e.target.closest('.search-container')) {
            autocompleteList.style.display = 'none';
        }
    });

    initIconCache();
    initMap();
    loadData();
</script>
</body>
</html>